---
title: "What is function overloading?"
description: "TypeScript'te function overloading hakkÄ±nda bilgi edinelim."
date: 2024-10-18
topic: "typescript"
tags:
  - overloading
  - function-signature
  - clean-code
---

**Function overloading** is the process of redefining a function with the same name but different
parameter combinations. The compiler or type system determines the correct function to call based on
the parameters.



## Function overloading in OOP languages

Java ve C++ gibi dillerde overload iÅŸlemi doÄŸrudan desteklenir. Derleyici, Ã§aÄŸrÄ±lan fonksiyonun
parametrelerine gÃ¶re doÄŸru metodu seÃ§er.

Java'da implementasyonu aÅŸaÄŸÄ±daki gibidir:

```java
class Notification {
  void send(String email, String message) {
    // ...
  }

  void send(String email, String message, boolean isUrgent) {
    // ...
  }

  void send(String email, String subject, String body) {
    // ...
  }
}

public class Main {
  public static void main(String[] args) {
    Notification notifier = new Notification();

    notifier.send("Hello!");
    notifier.send(
      "Reminder",
      "The meeting time has been changed to 10 AM."
    );
    notifier.send(
      "ensbaspinar@gmail.com",
      "Can you send me the plans for the team?",
      true
    );
  }
}
```

C++ dilinde de benzer bir implementasyon mevcuttur:

```cpp
class Notification {
public:
  void send(const string& message) {
    // ...
  }

  void send(const string& subject, const string& body) {
    // ...
  }

  void send(const string& email, const string& message, bool isUrgent) {
    // ...
  }
};

int main() {
  Notification notifier;

  notifier.send("Hello!");
  notifier.send(
    "Reminder",
    "The meeting time has been changed to 10 AM."
  );
  notifier.send(
    "ensbaspinar@gmail.com",
    "Can you send me the plans for the team?",
    true
  );
}
```

Bu Ã¶rneklerde `send` metodu farklÄ± sayÄ±da ve tÃ¼rde parametrelerle Ã§aÄŸrÄ±labilir.

### How does function overloading work?

1. Derleyici, aynÄ± isme sahip fonksiyonlarÄ±n imzalarÄ±nÄ± kontrol eder. EÄŸer bu fonksiyonlarÄ±n
parametre listeleri farklÄ±ysa, derleme baÅŸarÄ±lÄ± olur; aksi takdirde derleme hatasÄ± oluÅŸur.
2. AynÄ± isme sahip fonksiyonlarÄ± ayÄ±rt etmek iÃ§in **name mangling** tekniÄŸini kullanÄ±r. Bu teknik,
fonksiyon adlarÄ±nÄ± parametre sayÄ±sÄ± ve tÃ¼rleriyle birlikte kodlayarak benzersiz hale getirir.
Ã–rneÄŸin, `foo(int, double)` ve `foo(double, double)` fonksiyonlarÄ±nÄ±n isimleri derleyicide `foo_id`
ve `foo_dd` olarak temsil edilir.
3. Fonksiyon Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda derleyici argÃ¼man tÃ¼rlerini kontrol eder ve uygun fonksiyonu bulur.

## Function overloading in TypeScript

TypeScript doÄŸrudan OOP dilleri gibi overload desteklemez. Tek bir implementasyona birdan fazla imza
type'Ä± tanÄ±mlamanÄ±zÄ± saÄŸlar.

### Example

```typescript
class Notification {
  send(message: string): void;
  send(subject: string, body: string): void;
  send(email: string, message: string, isUrgent?: boolean): void;
  send(arg1: unknown, arg2?: unknown, arg3?: unknown): void {
    // Ä°mza send(message: string) ise
    if (typeof arg1 === "string" && !arg2 && !arg3) { 
      // ...
    } 

    // Ä°mza send(subject: string, body: string) ise
    else if (typeof arg1 === "string" && typeof arg2 === "string" && !arg3) { 
      // ...
    } 
    
    // Ä°mza send(email: string, message: string, isUrgent?: boolean) ise
    else if (typeof arg1 === "string" && typeof arg2 === "string" && typeof arg3 === "boolean") { 
      // ...
    }
  }
}

const notifier = new Notification();

notifier.send("Hello!");
notifier.send("Hello!");
notifier.send(
  "Reminder",
  "The meeting time has been changed to 10 AM."
);
notifier.send(
  "ensbaspinar@gmail.com",
  "Can you send me the plans for the team?",
  true
);
```

### Example 2

GeÃ§tiÄŸimiz aylarda ÅŸirkettekullandÄ±ÄŸÄ±m ve beni bu hook'u yazmaya iten hook Ã¶rneÄŸini de eklemiÅŸ
olayÄ±m.

```typescript
type Callback = () => void;

export function useSeenObserver(callback: Callback): React.RefObject<HTMLElement>;
export function useSeenObserver(selector: string, callback: Callback): void;
export function useSeenObserver(arg1: string | Callback, arg2?: Callback): React.RefObject<HTMLElement> | void {
  let element: Element;
  let callback: Callback;
  let ref = useRef<HTMLElement>(null);

  if (typeof arg1 === "string") {
    element = document.querySelector(arg1)!;
    callback = arg2!;
  } else {
    element = ref.current!;
    callback = arg1!;
  }

  // ...

  if (typeof arg1 !== "string") {
    return ref;
  }
}
```

Hook'u kullanÄ±rken return ettiÄŸimiz ref'i kullanarak ilgili elementi belirtebilirsiniz.

```typescript
const ref = useSeenObserver(() => {
  // ...
});

return <div ref={ref}></div>;
```

Ya da aÅŸaÄŸÄ±daki gibi bir selector kullanabilirsiniz.

```typescript
useSeenObserver("#component", () => {
  // ...
});

return <div id="component"></div>;
```

### How does function overloading work?

1. Fonksiyonun belirtilen imzalardan biriyle uyumlu olup olmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in
geliÅŸtirme ve derleme esnasÄ±nda tÃ¼r kontrolleri yapÄ±larak uyarÄ±r.
2. Typescript, JavaScript'e derlendiÄŸinden dolayÄ± **type safety** ve **signature check**
iÅŸlemleri runtime'da Ã§alÄ±ÅŸmaz. Bu sebepten Ã¶tÃ¼rÃ¼ fonksiyonun iÃ§erisinde parametre
tÃ¼rlerinin koÅŸullarla kontrol edilir.

### Why should I use it?

AynÄ± fonksiyonu union type ile tanÄ±mlamak da mÃ¼mkÃ¼ndÃ¼r ve bu sebeple neden signature
kullanmalÄ±yÄ±m sorusu aklÄ±nÄ±za gelebilir. Son Ã¶rneÄŸi signature kullanmadan yeniden yazalÄ±m.

```typescript
type Callback = () => void;

export function useSeenObserver(arg1: string | Callback, arg2?: Callback): React.RefObject<HTMLElement> | void {
  let element: Element;
  let callback: Callback;
  let ref = useRef<HTMLElement>(null);

  if (typeof arg1 === "string") {
    element = document.querySelector(arg1)!;
    callback = arg2!;
  } else {
    element = ref.current!;
    callback = arg1!;
  }

  // ...

  if (typeof arg1 !== "string") {
    return ref;
  }
}
```

Bu implementasyonu kullandÄ±ÄŸÄ±mÄ±zda TypeScript'in Ã¶nerdiÄŸi tipe ve yaptÄ±ÄŸÄ± kontrole gÃ¶rseldeki
gibidir.

![](./images/01.gif)

GÃ¶rebileceÄŸiniz Ã¼zere net bir template gÃ¶steremez. ArgÃ¼man isimleri ve hangi parametrenin
hangisiyle birlikte kullanÄ±labileceÄŸi bulanÄ±klaÅŸÄ±r. AÅŸaÄŸÄ±daki hiÃ§bir kombinasyonda TypeScript
hata vermez:

- `(arg1: string)` -> hatalÄ± kullanÄ±m
- `(arg1: string, arg2: Callback)` -> doÄŸru kullanÄ±m
- `(arg1: Callback)` -> doÄŸru kullanÄ±m
- `(arg1: Callback, arg2: Callback)` -> hatalÄ± kullanÄ±m

Signature kullandÄ±ÄŸÄ±nÄ±zda ise aÅŸaÄŸÄ±daki gibi doÄŸru bir API elde etmiÅŸ olursunuz.

![](./images/02.gif)

---

Function overloading, Ã¶zellikle bÃ¼yÃ¼k projelerde hatalara karÅŸÄ± dayanÄ±klÄ± bir API tasarÄ±mÄ± saÄŸlar.
Ama OOP dillerine gÃ¶re manual kontrollere gÃ¼venir ve kodu kirletir. Bu pattern ile genelde Ã§ok
fazla karÅŸÄ±laÅŸÄ±lmaz.

DiÄŸer yazÄ±larda buluÅŸalÄ±m ğŸ‘‹